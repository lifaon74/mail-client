import { GrammarRule } from './grammar/ast/grammar-rule/grammar-rule';
import { GrammarConcat } from './grammar/ast/grammar-concat/grammar-concat';
import {
  CHAR_0,
  CHAR_A_LOWER_CASE,
  CHAR_B_LOWER_CASE,
  CHAR_1,
  CHAR_2,
  CHAR_9,
  CHAR_Z_LOWER_CASE,
  CHAR_Z_UPPER_CASE,
  CHAR_A_UPPER_CASE,
  CHAR_F_LOWER_CASE,
  CHAR_F_UPPER_CASE,
  CHAR_DOUBLE_QUOTE,
  CHAR_EQUALS,
  CHAR_BACKSLASH,
  CHAR_SLASH,
  CHAR_SEMI_COLON,
  CHAR_SP,
  CHAR_LEFT_PARENTHESIS,
  CHAR_RIGHT_PARENTHESIS,
  CHAR_LEFT_ANGLE_BRACKET,
  CHAR_RIGHT_ANGLE_BRACKET,
  CHAR_AT_SIGN,
  CHAR_COMMA,
  CHAR_LEFT_SQUARE_BRACKET,
  CHAR_RIGHT_SQUARE_BRACKET,
  CHAR_QUESTION_MARK,
  CHAR_COLON,
  CHAR_HT,
  CHAR_CR,
  CHAR_LF,
} from '../../constants/chars/chars.constant';
import { IGrammarAstNode } from './grammar/ast/grammar/grammar-ast-node.type';
import { Grammar } from './grammar/ast/grammar/grammar';
import { ILines } from '../../misc/lines/lines.type';
import { linesToString } from '../../misc/lines/functions/lines-to-string';
import { IGrammarRuleAstNode } from './grammar/ast/grammar-rule/grammar-rule-ast-node.type';
import { GrammarAlternative } from './grammar/ast/grammar-alternative/grammar-alternative';
import { indentLines } from '../../misc/lines/functions/indent-lines';
import { IGrammarAlternativeAstNode, isGrammarAlternativeAstNode } from './grammar/ast/grammar-alternative/grammar-alternative-ast-node.type';
import { IGrammarConcatAstNode, isGrammarConcatAstNode } from './grammar/ast/grammar-concat/grammar-concat-ast-node.type';
import { IGrammarExpressionAstNode } from './grammar/ast/grammar-expression/grammar-expression-ast-node.type';
import {
  isGrammarRuleIdentifierAstNode,
  IGrammarRuleIdentifierAstNode,
} from './grammar/ast/grammar-rule-identifier/grammar-rule-identifier-ast-node.type';
import { GrammarRuleIdentifier } from './grammar/ast/grammar-rule-identifier/grammar-rule-identifier';
import { optimizeGrammar } from './grammar/ast/optimize/optimize-grammar';
import { IGrammarRepeatAstNode, isGrammarRepeatAstNode } from './grammar/ast/grammar-repeat/grammar-repeat-ast-node.type';
import { inlineLastLines } from '../../misc/lines/functions/after-last-line';
import { GrammarByteRange } from './grammar/ast/grammar-byte-sequence-comparison/shortcuts/grammar-byte-range';
import { GrammarByteComparison } from './grammar/ast/grammar-byte-sequence-comparison/shortcuts/grammar-byte-comparison';
import { range } from './grammar/ast/grammar-byte-sequence-comparison/comparisons/range/grammar-byte-comparison-range.shortcut';
import { or } from './grammar/ast/grammar-byte-sequence-comparison/comparisons/or/grammar-byte-comparison-or.shortcut';
import { GrammarByte } from './grammar/ast/grammar-byte-sequence-comparison/shortcuts/grammar-byte';
import { eq } from './grammar/ast/grammar-byte-sequence-comparison/comparisons/equals/grammar-byte-comparison-equals.shortcut';
import {
  isGrammarByteSequenceComparisonAstNode,
  IGrammarByteSequenceComparisonAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/grammar-byte-sequence-comparison-ast-node.type';
import {
  IGrammarByteComparisonAndAstNode,
  isGrammarByteComparisonAndAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/and/grammar-byte-comparison-and-ast-node.type';
import {
  IGrammarByteComparisonExpressionAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/grammar-byte-comparison-expression-ast-node.type';
import { IGenericAstNode } from '../../ast/__shared__/generic-ast-node.type';
import {
  IGrammarByteComparisonOrAstNode,
  isGrammarByteComparisonOrAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/or/grammar-byte-comparison-or-ast-node.type';
import {
  IGrammarByteComparisonEqualsAstNode,
  isGrammarByteComparisonEqualsAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/equals/grammar-byte-comparison-equals-ast-node.type';
import {
  IGrammarByteComparisonNotEqualsAstNode,
  isGrammarByteComparisonNotEqualsAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/not-equals/grammar-byte-comparison-not-equals-ast-node.type';
import {
  IGrammarByteComparisonGreaterThanAstNode,
  isGrammarByteComparisonGreaterThanAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/greater-than/grammar-byte-comparison-greater-than-ast-node.type';
import {
  isGrammarByteComparisonGreaterThanOrEqualsAstNode,
  IGrammarByteComparisonGreaterThanOrEqualsAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/greater-than-or-equals/grammar-byte-comparison-greater-than-or-equals-ast-node.type';
import {
  isGrammarByteComparisonLowerThanAstNode,
  IGrammarByteComparisonLowerThanAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/lower-than/grammar-byte-comparison-lower-than-ast-node.type';
import {
  isGrammarByteComparisonLowerThanOrEqualsAstNode,
  IGrammarByteComparisonLowerThanOrEqualsAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/lower-than-or-equals/grammar-byte-comparison-lower-than-or-equals-ast-node.type';
import {
  IGrammarByteComparisonNotAstNode,
  isGrammarByteComparisonNotAstNode,
} from './grammar/ast/grammar-byte-sequence-comparison/comparisons/not/grammar-byte-comparison-not-ast-node.type';
import { nor } from './grammar/ast/grammar-byte-sequence-comparison/comparisons/not-or/grammar-byte-comparison-not-or.shortcut';
import { GrammarByteSequence } from './grammar/ast/grammar-byte-sequence-comparison/shortcuts/grammar-byte-sequence';
import { GrammarRepeatOneOrMore } from './grammar/ast/grammar-repeat/shortcuts/grammar-repeat-one-or-more';
import { GrammarRepeatZeroOrMore } from './grammar/ast/grammar-repeat/shortcuts/grammar-repeat-zero-or-more';
import { GrammarByteSequenceComparison } from './grammar/ast/grammar-byte-sequence-comparison/grammar-byte-sequence-comparison';
import { GrammarString } from './grammar/ast/grammar-byte-sequence-comparison/shortcuts/grammar-string';
import { GrammarOptional } from './grammar/ast/grammar-repeat/shortcuts/grammar-optional';
import {
  IParsedUint8ArrayErrorAstNode,
  IGenericParsedUint8ArrayErrorAstNode,
} from './grammar/uint8-array-parser/ast/error/parsed-uint8-array-error-ast-node.type';
import { IUint8ArrayParser } from './grammar/uint8-array-parser/types/uint8-array-parser.type';
import {
  IParsedUint8ArrayErrorAlternativeAstNode
} from './grammar/uint8-array-parser/ast/error/alternative/parsed-uint8-array-error-alternative-ast-node.type';

/*---------*/
export type byte_t = number;

export type IDecoderResult<GValue> = IteratorResult<void, GValue>;

export type IDecoder<GValue> = Iterator<void, GValue, byte_t>;

export interface IDecoderFactory<GValue> {
  (): IDecoder<GValue>;
}

export type IDecoderGenerator<GValue> = Generator<void, GValue, byte_t>;

export interface IDecoderIterable<GValue> {
  [Symbol.iterator]: IDecoderFactory<GValue>;
}

export type IEncoder = Iterator<byte_t, void, void>;

/*---------*/

// export function textEncoder(
//   input: string,
// ): IEncoder {
//   new TextEncoder().encode(input);
// }

/*---------*/

/*
tutorial: https://tomassetti.me/guide-parsing-algorithms-terminology/

https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form
https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form

https://github.com/dhconnelly/prettybnf
from bnf to abnf: https://softwareengineering.stackexchange.com/questions/356419/is-repetition-expressed-in-backus-naur-form-by-recursive-production-definitions

 */


export interface IParsedUint8ArrayErrorConcatAstNode extends IParsedUint8ArrayErrorAstNode<'concat'> {
  readonly error: IGenericParsedUint8ArrayErrorAstNode;
}

export interface IParsedUint8ArrayErrorRepeatAstNode extends IParsedUint8ArrayErrorAstNode<'repeat'> {
  readonly error: IGenericParsedUint8ArrayErrorAstNode;
}

export interface IParsedUint8ArrayErrorByteSequenceAstNode extends IParsedUint8ArrayErrorAstNode<'byte-sequence'> {
}

export interface IParsedUint8ArrayErrorRuleAstNode extends IParsedUint8ArrayErrorAstNode<'rule'> {
  readonly name: string;
  readonly error: IGenericParsedUint8ArrayErrorAstNode;
}

export function transpileGrammarAlternativeToJavascriptParseUint8ArrayToAstFunction(
  {
    expressions,
  }: IGrammarAlternativeAstNode,
): ILines {
  return [
    `(buffer, index) => {`,
    ...indentLines([
      `const errors = [];`,
      ``,
      `const expressions = [`,
      ...indentLines([
        ...expressions.flatMap((expression: IGrammarExpressionAstNode): ILines => {
          return inlineLastLines(
            transpileGrammarExpressionToJavascriptParseUint8ArrayToAstFunction(expression),
            [`,`],
          );
        }),
      ]),
      `];`,
      ``,
      `for (let i = 0; i < ${expressions.length}; i++) {`,
      ...indentLines([
        `const result = expressions[i](buffer, index);`,
        ``,
        `if (result.type === 'error') {`,
        ...indentLines([
          `errors.push(result);`,
        ]),
        `} else {`,
        ...indentLines([
          `return {`,
          ...indentLines([
            `type: 'alternative',`,
            `start: index,`,
            `end: result.end,`,
            `children: [result],`,
          ]),
          `};`,
        ]),
        `}`,
      ]),
      `}`,
      ``,
      `return {`,
      ...indentLines([
        `type: 'error',`,
        `subType: 'alternative',`,
        `start: index,`,
        `end: index + 1,`, // TODO maybe errors(max(error.end))
        `errors,`,
      ]),
      `};`,
    ]),
    `}`,
  ];
}

export function transpileGrammarByteComparisonEqualsToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonEqualsAstNode,
  _value: string,
): ILines {
  return [
    `${_value} === ${value}`,
  ];
}

export function transpileGrammarByteComparisonGreaterThanToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonGreaterThanAstNode,
  _value: string,
): ILines {
  return [
    `${_value} > ${value}`,
  ];
}

export function transpileGrammarByteComparisonGreaterThanOrEqualsToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonGreaterThanOrEqualsAstNode,
  _value: string,
): ILines {
  return [
    `${_value} >= ${value}`,
  ];
}

export function transpileGrammarByteComparisonLowerThanToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonLowerThanAstNode,
  _value: string,
): ILines {
  return [
    `${_value} < ${value}`,
  ];
}

export function transpileGrammarByteComparisonLowerThanOrEqualsToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonLowerThanOrEqualsAstNode,
  _value: string,
): ILines {
  return [
    `${_value} <= ${value}`,
  ];
}

export function transpileGrammarByteComparisonNotEqualsToJavascriptBoolean(
  {
    value,
  }: IGrammarByteComparisonNotEqualsAstNode,
  _value: string,
): ILines {
  return [
    `${_value} !== ${value}`,
  ];
}

function multilineComparison(
  lines: ILines[],
  operator: string,
  ifEmptyLines: ILines,
): ILines {
  return (lines.length === 0)
    ? ifEmptyLines
    : lines.flatMap((lines: ILines, index: number): ILines => {
      return [
        ...((index > 0) ? [`${operator} `] : []),
        `(`,
        ...indentLines(lines),
        `)`,
      ];
    });
}

export function transpileGrammarByteComparisonAndToJavascriptBoolean(
  {
    expressions,
  }: IGrammarByteComparisonAndAstNode,
  value: string,
): ILines {
  return multilineComparison(
    expressions.map((expression: IGrammarByteComparisonExpressionAstNode): ILines => {
      return transpileGrammarByteComparisonExpressionToJavascriptBoolean(expression, value);
    }),
    '&&',
    [`true`],
  );
}

export function transpileGrammarByteComparisonOrToJavascriptBoolean(
  {
    expressions,
  }: IGrammarByteComparisonOrAstNode,
  value: string,
): ILines {
  return multilineComparison(
    expressions.map((expression: IGrammarByteComparisonExpressionAstNode): ILines => {
      return transpileGrammarByteComparisonExpressionToJavascriptBoolean(expression, value);
    }),
    '||',
    [`false`],
  );
}

export function transpileGrammarByteComparisonNotToJavascriptBoolean(
  {
    expression,
  }: IGrammarByteComparisonNotAstNode,
  value: string,
): ILines {
  return [
    `!(`,
    ...indentLines(
      transpileGrammarByteComparisonExpressionToJavascriptBoolean(expression, value),
    ),
    `)`,
  ];
}

export function transpileGrammarByteComparisonExpressionToJavascriptBoolean(
  node: IGrammarByteComparisonExpressionAstNode,
  value: string,
): ILines {
  if (isGrammarByteComparisonAndAstNode(node)) {
    return transpileGrammarByteComparisonAndToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonEqualsAstNode(node)) {
    return transpileGrammarByteComparisonEqualsToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonGreaterThanAstNode(node)) {
    return transpileGrammarByteComparisonGreaterThanToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonGreaterThanOrEqualsAstNode(node)) {
    return transpileGrammarByteComparisonGreaterThanOrEqualsToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonLowerThanAstNode(node)) {
    return transpileGrammarByteComparisonLowerThanToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonLowerThanOrEqualsAstNode(node)) {
    return transpileGrammarByteComparisonLowerThanOrEqualsToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonNotAstNode(node)) {
    return transpileGrammarByteComparisonNotToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonNotEqualsAstNode(node)) {
    return transpileGrammarByteComparisonNotEqualsToJavascriptBoolean(node, value);
  } else if (isGrammarByteComparisonOrAstNode(node)) {
    return transpileGrammarByteComparisonOrToJavascriptBoolean(node, value);
  } else {
    throw new Error(`Unknown node: ${(node as IGenericAstNode).__type__}`);
  }
}

export function transpileGrammarByteSequenceComparisonToJavascriptParseUint8ArrayToAstFunction(
  {
    expressions,
  }: IGrammarByteSequenceComparisonAstNode,
): ILines {
  return [
    `(buffer, index) => {`,
    ...indentLines([
      ...expressions.flatMap((_, index: number): ILines => {
        return [
          `const b${index} = buffer[index + ${index}];`,
        ];
      }),
      ``,
      `return (`,
      ...indentLines(
        multilineComparison(
          expressions.map((expression: IGrammarByteComparisonExpressionAstNode, index: number): ILines => {
            return transpileGrammarByteComparisonExpressionToJavascriptBoolean(expression, `b${index}`);
          }),
          '&&',
          [`true`],
        ),
      ),
      `) `,
      ...indentLines([
        `? {`,
        ...indentLines([
          `type: 'byte-sequence',`,
          `start: index,`,
          `end: index + ${expressions.length},`,
          `children: [],`,
        ]),
        `} : {`,
        ...indentLines([
          `type: 'error',`,
          `subType: 'byte-sequence',`,
          `start: index,`,
          `end: index + ${expressions.length},`,
        ]),
        `};`,
      ]),
    ]),
    `}`,
  ];
}

export function transpileGrammarConcatToJavascriptParseUint8ArrayToAstFunction(
  {
    expressions,
  }: IGrammarConcatAstNode,
): ILines {
  return [
    `(buffer, index) => {`,
    ...indentLines([
      `const children = new Array(${expressions.length});`,
      `let _index = index;`,
      ``,
      `const expressions = [`,
      ...indentLines([
        ...expressions.flatMap((expression: IGrammarExpressionAstNode): ILines => {
          return inlineLastLines(
            transpileGrammarExpressionToJavascriptParseUint8ArrayToAstFunction(expression),
            [`,`],
          );
        }),
      ]),
      `];`,
      ``,
      `for (let i = 0; i < ${expressions.length}; i++) {`,
      ...indentLines([
        `const result = expressions[i](buffer, _index);`,
        ``,
        `if (result.type === 'error') {`,
        ...indentLines([
          `return {`,
          ...indentLines([
            `type: 'error',`,
            `subType: 'concat',`,
            `start: index,`,
            `end: result.end,`,
            `error: result,`,
          ]),
          `};`,
        ]),
        `} else {`,
        ...indentLines([
          `children[i] = result;`,
          `_index = result.end;`,
        ]),
        `}`,
      ]),
      `}`,
      ``,
      `return {`,
      ...indentLines([
        `type: 'concat',`,
        `start: index,`,
        `end: _index,`,
        `children,`,
      ]),
      `};`,
    ]),
    `}`,
  ];
}

export function transpileGrammarExpressionToJavascriptParseUint8ArrayToAstFunction(
  node: IGrammarExpressionAstNode,
): ILines {
  if (isGrammarAlternativeAstNode(node)) {
    return transpileGrammarAlternativeToJavascriptParseUint8ArrayToAstFunction(node);
  } else if (isGrammarByteSequenceComparisonAstNode(node)) {
    return transpileGrammarByteSequenceComparisonToJavascriptParseUint8ArrayToAstFunction(node);
  } else if (isGrammarConcatAstNode(node)) {
    return transpileGrammarConcatToJavascriptParseUint8ArrayToAstFunction(node);
  } else if (isGrammarRepeatAstNode(node)) {
    return transpileGrammarRepeatToJavascriptParseUint8ArrayToAstFunction(node);
  } else if (isGrammarRuleIdentifierAstNode(node)) {
    return transpileGrammarRuleIdentifierToJavascriptParseUint8ArrayToAstFunction(node);
  } else {
    throw new Error(`Unknown node: ${(node as any).type}`);
  }
}

export function transpileGrammarRepeatToJavascriptParseUint8ArrayToAstFunction(
  {
    expression,
    min,
    max,
  }: IGrammarRepeatAstNode,
): ILines {
  return [

    `(buffer, index) => {`,
    ...indentLines([
      `let children = [];`,
      `let _index = index;`,
      ``,
      `const expression = (`,
      ...indentLines([
        ...transpileGrammarExpressionToJavascriptParseUint8ArrayToAstFunction(expression),
      ]),
      `);`,
      ``,
      `for (let i = 0; i <= ${max}; i++) {`,
      ...indentLines([
        `const result = expression(buffer, _index);`,

        `if (result.type === 'error') {`,
        // TODO improve from ranges
        ...indentLines([
          `if (${(min === max) ? `i === ${min}` : `(${min} <= i) && (i <= ${max})`}) {`,
          ...indentLines([
            `break;`,
          ]),
          `} else {`,
          ...indentLines([
            `return {`,
            ...indentLines([
              `type: 'error',`,
              `subType: 'repeat',`,
              `start: index,`,
              `end: result.end,`,
              `error: result,`,
            ]),
            `};`,
          ]),
          `}`,
        ]),
        `} else {`,
        ...indentLines([
          `children.push(result);`,
          `_index = result.end;`,
        ]),
        `}`,
      ]),
      `}`,
      ``,
      `return {`,
      ...indentLines([
        `type: 'repeat',`,
        `start: index,`,
        `end: _index,`,
        `children,`,
      ]),
      `};`,
    ]),
    `}`,
  ];
}

export function transpileGrammarRuleToJavascriptParseUint8ArrayToAstFunction(
  {
    name,
    expression,
  }: IGrammarRuleAstNode,
): ILines {
  return [
    `rules.set(${JSON.stringify(name)}, (buffer, index) => {`,
    ...indentLines([
      `const result = (`,
      ...indentLines([
        ...transpileGrammarExpressionToJavascriptParseUint8ArrayToAstFunction(expression),
      ]),
      `)(buffer, index);`,
      ``,
      `if (result.type === 'error') {`,
      ...indentLines([
        `return {`,
        ...indentLines([
          `type: 'error',`,
          `subType: 'rule',`,
          `start: index,`,
          `end: result.end,`,
          `name: ${JSON.stringify(name)},`,
          `error: result,`,
        ]),
        `};`,
      ]),
      `} else {`,
      ...indentLines([
        `return {`,
        ...indentLines([
          `type: 'rule',`,
          `start: index,`,
          `end: result.end,`,
          `children: [result],`,
          `name: ${JSON.stringify(name)},`,
        ]),
        `};`,
      ]),
      `}`,
    ]),
    `});`,
  ];
}

export function transpileGrammarRuleIdentifierToJavascriptParseUint8ArrayToAstFunction(
  {
    name,
  }: IGrammarRuleIdentifierAstNode,
): ILines {
  return [
    `(buffer, index) => {`,
    ...indentLines([
      `return rules.get(${JSON.stringify(name)})(buffer, index);`,
    ]),
    `}`,
  ];
}

export function transpileGrammarToJavascriptParseUint8ArrayToAstFunction(
  {
    rules,
  }: IGrammarAstNode,
): ILines {
  return [
    `(`,
    ...indentLines([
      `rules = new Map(),`,
    ]),
    `) => {`,
    ...indentLines([
      ...rules.flatMap(transpileGrammarRuleToJavascriptParseUint8ArrayToAstFunction),
      `return rules;`,
    ]),
    `}`,
  ];
}

export type IUint8ArrayParserRules = Map<string, IUint8ArrayParser>;

export interface IGrammarForUint8ArrayParser {
  (
    rules?: IUint8ArrayParserRules,
  ): IUint8ArrayParserRules;
}

export function compileAndOptimizeGrammarToJavascriptParseUint8ArrayToAstFunction(
  grammar: IGrammarAstNode,
): IGrammarForUint8ArrayParser {
  return compileGrammarToJavascriptParseUint8ArrayToAstFunction(
    optimizeGrammar(grammar),
  );
}

export function compileGrammarToJavascriptParseUint8ArrayToAstFunction(
  grammar: IGrammarAstNode,
): IGrammarForUint8ArrayParser {
  const code: string = linesToString(
    transpileGrammarToJavascriptParseUint8ArrayToAstFunction(
      grammar,
    ),
  );

  console.log(code);

  return new Function('rules', `return (${code})(rules);`) as IGrammarForUint8ArrayParser;
}

/*---------*/

// console.groupCollapsed(`${error.name}: ${error.message}`);
// console.error(error);
// console.log(`at index ${error.start} of:`);
// console.log(error.buffer);
//
// const chunkAStyle: string = '';
// const chunkBStyle: string = 'color: red; font-weight: bold';
// const chunkCStyle: string = 'color: rgba(255, 0, 0, 0.7);';
//
// const chunkA: Uint8Array = error.buffer.slice(Math.max(0, error.start - extra), error.start);
// const chunkB: Uint8Array = error.buffer.slice(error.start, error.end);
// const chunkC: Uint8Array = error.buffer.slice(error.end + 1, error.end + extra);
//
// console.log(`%c...${chunkA.join(', ')}, %c${chunkB.join(', ')}, %c${chunkC.join(', ')}...`, chunkAStyle, chunkBStyle, chunkCStyle);
// console.log(`%c...${new TextDecoder().decode(chunkA)}%c${new TextDecoder().decode(chunkB)}%c${new TextDecoder().decode(chunkC)}...`, chunkAStyle, chunkBStyle, chunkCStyle);
// console.groupEnd();

export function printBufferChunkError(
  buffer: Uint8Array,
  start: number,
  end: number,
  extra: number = 30,
): void {

  const chunkBeforeStyle: string = '';
  const chunkErroredStyle: string = 'color: red; font-weight: bold';
  const chunkAfterStyle: string = 'color: rgba(255, 0, 0, 0.7);';

  const chunkBeforeStart: number = Math.max(0, start - extra);
  const chunkAfterEnd: number = Math.min(buffer.length, end + extra);

  const chunkBefore: Uint8Array = buffer.slice(chunkBeforeStart, start);
  const chunkErrored: Uint8Array = buffer.slice(start, end);
  const chunkAfter: Uint8Array = buffer.slice(end + 1, chunkAfterEnd);

  const before = (value: string = '...'): string => {
    return (chunkBeforeStart === 0)
      ? ''
      : value;
  };

  const after = (value: string = '...'): string => {
    return (chunkAfterEnd === buffer.length)
      ? ''
      : value;
  };

  const afterIfNotEmpty = (input: string, after: string): string => {
    return (input === '')
      ? ''
      : `${input}${after}`;
  };

  const bytes = (chunk: Uint8Array): string => {
    return chunk.join(', ');
  };

  const chars = (chunk: Uint8Array): string => {
    return new TextDecoder().decode(chunk);
  };

  console.log(`from index ${start} to ${end}:`);
  console.log(`%c${before()}${afterIfNotEmpty(bytes(chunkBefore), ', ')}%c${afterIfNotEmpty(bytes(chunkErrored), ', ')}%c${bytes(chunkAfter)}${after()}`, chunkBeforeStyle, chunkErroredStyle, chunkAfterStyle);
  console.log(`%c${before()}${chars(chunkBefore)}%c${chars(chunkErrored)}%c${chars(chunkAfter)}${after()}`, chunkBeforeStyle, chunkErroredStyle, chunkAfterStyle);
}

export function printGrammarErrorBuffer(
  buffer: Uint8Array,
  {
    start,
    end,
  }: IGenericParsedUint8ArrayErrorAstNode,
): void {
  printBufferChunkError(buffer, start, end);
}

export function printGrammarAlternativeError(
  buffer: Uint8Array,
  {
    errors,
  }: IParsedUint8ArrayErrorAlternativeAstNode,
): void {
  console.log('Alternative:');
  errors.forEach((error: IGenericParsedUint8ArrayErrorAstNode, index: number): void => {
    console.groupCollapsed(`alternative - ${index}`);
    printGrammarError(buffer, error);
    console.groupEnd();
  });
}

export function printGrammarConcatError(
  buffer: Uint8Array,
  node: IParsedUint8ArrayErrorConcatAstNode,
): void {
  printGrammarError(buffer, node.error);
}

export function printGrammarByteSequenceError(
  buffer: Uint8Array,
  node: IParsedUint8ArrayErrorByteSequenceAstNode,
): void {
  printGrammarErrorBuffer(buffer, node);
}

export function printGrammarRepeatError(
  buffer: Uint8Array,
  node: IParsedUint8ArrayErrorRepeatAstNode,
): void {
  printGrammarError(buffer, node.error);
}

export function printGrammarRuleError(
  buffer: Uint8Array,
  {
    name,
    error,
  }: IParsedUint8ArrayErrorRuleAstNode,
): void {
  console.groupCollapsed(`in rule: ${name}`);
  printGrammarError(buffer, error);
  console.groupEnd();
}

export function printGrammarError(
  buffer: Uint8Array,
  node: IGenericParsedUint8ArrayErrorAstNode,
): void {
  if (node.__subtype__ === 'alternative') {
    printGrammarAlternativeError(buffer, node as any);
  } else if (node.__subtype__ === 'concat') {
    printGrammarConcatError(buffer, node as any);
  } else if (node.__subtype__ === 'byte-sequence') {
    printGrammarByteSequenceError(buffer, node as any);
  } else if (node.__subtype__ === 'repeat') {
    printGrammarRepeatError(buffer, node as any);
  } else if (node.__subtype__ === 'rule') {
    printGrammarRuleError(buffer, node as any);
  } else {
    console.log('TODO', node.__subtype__);
  }
}

/*---------*/

function grammarDebug1(): void {
  const digit = GrammarRule('digit', GrammarByteRange(CHAR_0, CHAR_9));
  const alpha_lowercase = GrammarRule('alpha_lowercase', GrammarAlternative(
    GrammarByte(CHAR_A_LOWER_CASE),
    GrammarByte(CHAR_B_LOWER_CASE),
    GrammarRuleIdentifier('digit'),
  ));

  const grammar = Grammar([
    digit,
    alpha_lowercase,
  ]);
  // console.log(grammar);

  const optimizedGrammar = optimizeGrammar(grammar);

  console.log(optimizedGrammar);

  // console.log(optimizeGrammarConcat(GrammarConcat([GrammarByte(CHAR_0), GrammarByte(CHAR_1), GrammarByte(CHAR_2)])));
  // console.log(optimizeGrammarAlternative(GrammarAlternative([GrammarByte(CHAR_0), GrammarByte(CHAR_1), GrammarByte(CHAR_2)])));
  // console.log(optimizeGrammarRule(alpha_lowercase));
  // console.log(optimizeGrammar(grammar));

  // // const lines: ILines = transpileGrammarByteToJavascriptParseUint8ArrayToAstFunction(GrammarByte(CHAR_0));
  // // const lines: ILines = transpileGrammarConcatToJavascriptParseUint8ArrayToAstFunction(GrammarConcat([GrammarByte(CHAR_0), GrammarByte(CHAR_1)]));
  // // const lines: ILines = transpileGrammarAlternativeToJavascriptParseUint8ArrayToAstFunction(GrammarAlternative([GrammarByte(CHAR_0), GrammarByte(CHAR_1)]));
  // const lines: ILines = transpileGrammarRuleToJavascriptParseUint8ArrayToAstFunction(digit);
  // // const lines: ILines = transpileGrammarRuleToJavascriptParseUint8ArrayToAstFunction(alpha_lowercase);
  // // const lines: ILines = transpileGrammarToJavascriptParseUint8ArrayToAstFunction(grammar);
  //
  // const code: string = linesToString(lines);
  //
  // console.log(code);
  //
  // const fnc = new Function('buffer', 'index', `return (${code})(buffer, index);`);
  //
  // console.log(fnc([CHAR_0, CHAR_1], 0));
  // // console.log(fnc([CHAR_A_LOWER_CASE, CHAR_1], 0));
}

// email rfc: https://datatracker.ietf.org/doc/html/rfc2045
// email rfc: https://datatracker.ietf.org/doc/html/rfc2046
// MIME type rfc: https://datatracker.ietf.org/doc/html/rfc2425#section-15

function grammarDebug2(): void {
  const digit = GrammarRule('digit', GrammarByteRange(CHAR_0, CHAR_9));
  const hex_digit = GrammarRule(
    'hex_digit',
    GrammarAlternative(
      GrammarRuleIdentifier('digit'),
      // GrammarByteComparison(
      //   or(
      //     range(CHAR_A_LOWER_CASE, CHAR_F_LOWER_CASE),
      //     range(CHAR_A_UPPER_CASE, CHAR_F_UPPER_CASE),
      //   )
      // ),
      GrammarByteRange(CHAR_A_LOWER_CASE, CHAR_F_LOWER_CASE),
      GrammarByteRange(CHAR_A_UPPER_CASE, CHAR_F_UPPER_CASE),
    ),
  );

  const alpha_lower_case = GrammarRule('alpha_lower_case', GrammarByteRange(CHAR_A_LOWER_CASE, CHAR_Z_LOWER_CASE));
  const alpha_upper_case = GrammarRule('alpha_upper_case', GrammarByteRange(CHAR_A_UPPER_CASE, CHAR_Z_UPPER_CASE));
  const alpha = GrammarRule('alpha',
    GrammarAlternative(
      GrammarRuleIdentifier('alpha_lower_case'),
      GrammarRuleIdentifier('alpha_upper_case'),
    ),
  );

  const grammar = Grammar([
    digit,
    hex_digit,
    alpha_lower_case,
    alpha_upper_case,
    alpha,
  ]);

  const compiledGrammar = compileAndOptimizeGrammarToJavascriptParseUint8ArrayToAstFunction(grammar);
  const rules = compiledGrammar();

  const buffer = new Uint8Array([CHAR_0, CHAR_1, CHAR_2]);

  const tree = rules.get('alpha')!(buffer, 0);

  console.log(tree);

  printGrammarError(buffer, tree as any);
}

function grammarDebug3(): void {
  // mime-type: https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
  // list of iana mime-types: https://www.iana.org/assignments/media-types/media-types.xhtml#multipart

  /*
  // http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf

  named-field = field-name ":" [ field-value ]
 field-name = token
 field-value = *( field-content | LWS ) ; further qualified
 ; by field
 ; definitions
 field-content = <the OCTETs making up the field-value
 and consisting of either *TEXT or combinations
 of token, separators, and quoted-string>
 OCTET = <any 8-bit sequence of data>
 token = 1*<any US-ASCII character
 except CTLs or separators>
 separators = "(" | ")" | "<" | ">" | "@"
 | "," | ";" | ":" | "\" | <">
 | "/" | "[" | "]" | "?" | "="
 | "{" | "}" | SP | HT
 TEXT = <any OCTET except CTLs,
 but including LWS>
 CHAR = <UTF-8 characters; RFC3629> ; (0-191, 194-244)
 DIGIT = <any US-ASCII digit "0".."9">
 CTL = <any US-ASCII control character
 (octets 0 - 31) and DEL (127)>
 CR = <ASCII CR, carriage return> ; (13)
ISO 28500
© ISO 2006 — All rights reserved 5
 LF = <ASCII LF, linefeed> ; (10)
 SP = <ASCII SP, space> ; (32)
 HT = <ASCII HT, horizontal-tab> ; (9)
 CRLF = CR LF
 LWS = [CRLF] 1*( SP | HT ) ; semantics same as
 ; single SP
 quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 qdtext = <any TEXT except <">>
 quoted-pair = "\" CHAR ; single-character quoting
 uri = "<" <'URI' per RFC3986> ">"

   */

  const CTL = or(
    range(0x00, 0x1f),
    eq(0x7f),
  );

  const mime_type = GrammarRule('mime-type', GrammarConcat(
    GrammarRuleIdentifier('type'),
    GrammarByte(CHAR_SLASH),
    GrammarRuleIdentifier('subtype'),
    GrammarRepeatZeroOrMore(
      GrammarConcat(
        GrammarByte(CHAR_SEMI_COLON),
        GrammarRuleIdentifier('parameter'),
      ),
    ),
  ));

  const type = GrammarRule('type', GrammarRuleIdentifier('token'));

  const subtype = GrammarRule('subtype', GrammarRuleIdentifier('token'));

  const parameter = GrammarRule('parameter', GrammarConcat(
    GrammarRuleIdentifier('attribute'),
    GrammarByte(CHAR_EQUALS),
    GrammarRuleIdentifier('value'),
  ));

  const attribute = GrammarRule('attribute', GrammarRuleIdentifier('token'));

  const value = GrammarRule('value', GrammarAlternative(
    GrammarRuleIdentifier('token'),
    GrammarRuleIdentifier('quoted-string'),
  ));

  const tspecials = or(
    eq(CHAR_LEFT_PARENTHESIS),
    eq(CHAR_RIGHT_PARENTHESIS),
    eq(CHAR_LEFT_ANGLE_BRACKET),
    eq(CHAR_RIGHT_ANGLE_BRACKET),
    eq(CHAR_AT_SIGN),
    eq(CHAR_COMMA),
    eq(CHAR_SEMI_COLON),
    eq(CHAR_COLON),
    eq(CHAR_BACKSLASH),
    eq(CHAR_DOUBLE_QUOTE),
    eq(CHAR_SLASH),
    eq(CHAR_LEFT_SQUARE_BRACKET),
    eq(CHAR_RIGHT_SQUARE_BRACKET),
    eq(CHAR_QUESTION_MARK),
    eq(CHAR_EQUALS),
  );

  const token = GrammarRule('token', GrammarRepeatOneOrMore(
    GrammarByteComparison(
      nor(
        eq(CHAR_SP),
        CTL,
        tspecials,
      ),
    ),
  ));

  const quoted_string = GrammarRule('quoted-string', GrammarConcat(
    GrammarByte(CHAR_DOUBLE_QUOTE),
    GrammarRepeatZeroOrMore(
      GrammarAlternative(
        GrammarRuleIdentifier('quoted-string-token'),
        GrammarRuleIdentifier('quoted-pair'),
      ),
    ),
    GrammarByte(CHAR_DOUBLE_QUOTE),
  ));

  const quoted_pair = GrammarRule('quoted-pair', GrammarByteSequence([
    CHAR_BACKSLASH,
    CHAR_DOUBLE_QUOTE,
  ]));

  const quoted_string_token = GrammarRule('quoted-string-token', GrammarByteComparison(
    or(
      eq(0x09),
      range(0x20 /* SP */, 0x21 /* ! */),
      // exclude "
      range(0x23 /* # */, 0x7e /* ~ */),
    ),
  ));

  const grammar = Grammar([
    mime_type,
    type,
    subtype,
    parameter,
    attribute,
    value,
    token,
    quoted_string,
    quoted_pair,
    quoted_string_token,
  ]);

  const optimizedGrammar = optimizeGrammar(grammar);

  console.log(optimizedGrammar);
  console.log(optimizedGrammar === grammar);

  const compiledGrammar = compileAndOptimizeGrammarToJavascriptParseUint8ArrayToAstFunction(grammar);
  const rules = compiledGrammar();

  // const buffer = new Uint8Array([CHAR_0, CHAR_1, CHAR_2]);
  const buffer = new TextEncoder().encode('image/png; asefesf="i7888888888888888\\"888888888888888888888888888888888"');
  console.log(buffer);

  const tree = rules.get('mime-type')!(buffer, 0);

  console.log(tree);

  printGrammarError(buffer, tree as any);

  // console.log(optimizeGrammarExpression(
  //   GrammarAlternative([
  //     GrammarByte(CHAR_BACKSLASH),
  //     GrammarByte(CHAR_DOUBLE_QUOTE),
  //   ]),
  //   // GrammarConcat([
  //   //   GrammarByte(CHAR_BACKSLASH),
  //   //   GrammarByte(CHAR_DOUBLE_QUOTE),
  //   // ]),
  // ));
}

// export const ABNF_ALPHA_LOWER_CASE = range(CHAR_A_LOWER_CASE, CHAR_Z_LOWER_CASE);
// export const ABNF_ALPHA_UPPER_CASE = range(CHAR_A_UPPER_CASE, CHAR_Z_UPPER_CASE);
// export const ABNF_ALPHA = or(
//   ABNF_ALPHA_LOWER_CASE,
//   ABNF_ALPHA_UPPER_CASE,
// );
//
// export const ABNF_DIGIT = range(CHAR_0, CHAR_9);
// export const ABNF_HEXDIG = or(
//   ABNF_DIGIT,
//   range(CHAR_A_LOWER_CASE, CHAR_F_LOWER_CASE),
//   range(CHAR_A_UPPER_CASE, CHAR_F_UPPER_CASE),
// );
//
// const ABNF_DQUOTE = eq(CHAR_DOUBLE_QUOTE);
// const ABNF_SP = eq(CHAR_SP);
// const ABNF_HTAB = eq(CHAR_HT);
// const ABNF_WSP = or(
//   ABNF_SP,
//   ABNF_HTAB,
// );
// export const ABNF_LWSP_RULE = GrammarRule('LWSP', GrammarRepeatZeroOrMore(
//   GrammarAlternative(
//     GrammarByteSequenceComparison(ABNF_WSP),
//     GrammarConcat(
//       GrammarRuleIdentifier('CRLF'),
//       GrammarByteSequenceComparison(ABNF_WSP),
//     ),
//   ),
// ));
// export const ABNF_VCHAR = range(0x21, 0x7e);
// export const ABNF_CHAR = range(0x01, 0x7f);
// export const ABNF_OCTET = range(0x00, 0xff);
// export const ABNF_CTL = or(
//   range(0x00, 0x1f),
//   eq(0x7f),
// );
// export const ABNF_CR = eq(CHAR_CR);
// export const ABNF_LF = eq(CHAR_LF);
// export const ABNF_CRLF_RULE = GrammarRule('CRLF', GrammarByteSequenceComparison(
//   ABNF_CR,
//   ABNF_LF,
// ));
// const ABNF_BIT = or(
//   eq(CHAR_0),
//   eq(CHAR_1),
// );

function grammarDebugABNF(): void {
  // https://www.rfc-editor.org/rfc/rfc5234

  const ALPHA_LOWER_CASE = GrammarRule('ALPHA_LOWER_CASE', GrammarByteRange(CHAR_A_LOWER_CASE, CHAR_Z_LOWER_CASE));
  const ALPHA_UPPER_CASE = GrammarRule('ALPHA_UPPER_CASE', GrammarByteRange(CHAR_A_UPPER_CASE, CHAR_Z_UPPER_CASE));
  const ALPHA = GrammarRule('ALPHA', GrammarAlternative(
    GrammarRuleIdentifier('ALPHA_LOWER_CASE'),
    GrammarRuleIdentifier('ALPHA_UPPER_CASE'),
  ));
  const DIGIT = GrammarRule('DIGIT', GrammarByteRange(CHAR_0, CHAR_1));
  const HEXDIG = GrammarRule('HEXDIG', GrammarAlternative(
    GrammarRuleIdentifier('DIGIT'),
    GrammarByteRange(CHAR_A_LOWER_CASE, CHAR_F_LOWER_CASE),
    GrammarByteRange(CHAR_F_UPPER_CASE, CHAR_F_UPPER_CASE),
  ));
  const DQUOTE = GrammarRule('DQUOTE', GrammarByte(CHAR_DOUBLE_QUOTE));
  const SP = GrammarRule('SP', GrammarByte(CHAR_SP));
  const HTAB = GrammarRule('HTAB', GrammarByte(CHAR_HT));
  const WSP = GrammarRule('WSP', GrammarAlternative(
    GrammarRuleIdentifier('SP'),
    GrammarRuleIdentifier('HTAB'),
  ));
  const LWSP = GrammarRule('LWSP', GrammarRepeatZeroOrMore(
    GrammarAlternative(
      GrammarRuleIdentifier('WSP'),
      GrammarConcat(
        GrammarRuleIdentifier('CRLF'),
        GrammarRuleIdentifier('WSP'),
      ),
    ),
  ));
  const VCHAR = GrammarRule('VCHAR', GrammarByteRange(0x21, 0x7e));
  const CHAR = GrammarRule('CHAR', GrammarByteRange(0x01, 0x7f));
  const OCTET = GrammarRule('OCTET', GrammarByteRange(0x00, 0xff));
  const CTL = GrammarRule('CTL', GrammarByteComparison(
    or(
      range(0x00, 0x1f),
      eq(0x7f),
    ),
  ));
  const CR = GrammarRule('CR', GrammarByte(CHAR_CR));
  const LF = GrammarRule('LF', GrammarByte(CHAR_LF));
  const CRLF = GrammarRule('CRLF', GrammarConcat(
    GrammarRuleIdentifier('CR'),
    GrammarRuleIdentifier('LF'),
  ));
  const BIT = GrammarRule('BIT', GrammarByteComparison(
    or(
      eq(CHAR_0),
      eq(CHAR_1),
    ),
  ));

  const ABNF_RULES = [
    ALPHA_LOWER_CASE,
    ALPHA_UPPER_CASE,
    ALPHA,
    DIGIT,
    HEXDIG,
    DQUOTE,
    SP,
    HTAB,
    WSP,
    LWSP,
    VCHAR,
    CHAR,
    OCTET,
    CTL,
    CR,
    LF,
    CRLF,
    BIT,
  ];

  const rulelist = GrammarRule('rulelist', GrammarRepeatOneOrMore(
    GrammarAlternative(
      GrammarRuleIdentifier('rule'),
      GrammarConcat(
        GrammarRepeatZeroOrMore(
          GrammarRuleIdentifier('c-wsp'),
        ),
        GrammarRuleIdentifier('c-nl'),
      ),
    ),
  ));

  const rule = GrammarRule('rule', GrammarConcat(
    GrammarRuleIdentifier('rulename'),
    GrammarRuleIdentifier('defined-as'),
    GrammarRuleIdentifier('elements'),
    GrammarRuleIdentifier('c-nl'),
  ));

  const rulename = GrammarRule('rulename', GrammarConcat(
    GrammarRuleIdentifier('ALPHA'),
    GrammarRepeatZeroOrMore(
      GrammarAlternative(
        GrammarRuleIdentifier('ALPHA'),
        GrammarRuleIdentifier('DIGIT'),
        GrammarString('-'),
      ),
    ),
  ));

  const defined_as = GrammarRule('defined-as', GrammarConcat(
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
    GrammarAlternative(
      GrammarString('='),
      GrammarString('=/'),
    ),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
  ));

  const elements = GrammarRule('elements', GrammarConcat(
    GrammarRuleIdentifier('alternation'),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
  ));

  const c_wsp = GrammarRule('c-wsp', GrammarAlternative(
    GrammarRuleIdentifier('WSP'),
    GrammarConcat(
      GrammarRuleIdentifier('c-nl'),
      GrammarRuleIdentifier('WSP'),
    ),
  ));

  const c_nl = GrammarRule('c-nl', GrammarAlternative(
    GrammarRuleIdentifier('comment'),
    GrammarRuleIdentifier('CRLF'),
  ));

  const comment = GrammarRule('comment', GrammarConcat(
    GrammarString(';'),
    GrammarRepeatZeroOrMore(
      GrammarAlternative(
        GrammarRuleIdentifier('WSP'),
        GrammarRuleIdentifier('VCHAR'),
      ),
    ),
    GrammarRuleIdentifier('CRLF'),
  ));

  const alternation = GrammarRule('alternation', GrammarConcat(
    GrammarRuleIdentifier('concatenation'),
    GrammarRepeatZeroOrMore(
      GrammarConcat(
        GrammarRepeatZeroOrMore(
          GrammarRuleIdentifier('c-wsp'),
        ),
        GrammarString('/'),
        GrammarRepeatZeroOrMore(
          GrammarRuleIdentifier('c-wsp'),
        ),
        GrammarRuleIdentifier('concatenation'),
      ),
    ),
  ));

  const concatenation = GrammarRule('concatenation', GrammarConcat(
    GrammarRuleIdentifier('repetition'),
    GrammarRepeatZeroOrMore(
      GrammarConcat(
        GrammarRepeatOneOrMore(
          GrammarRuleIdentifier('c-wsp'),
        ),
        GrammarRuleIdentifier('repetition'),
      ),
    ),
  ));

  const repetition = GrammarRule('repetition', GrammarConcat(
    GrammarOptional(
      GrammarRuleIdentifier('repeat'),
    ),
    GrammarRuleIdentifier('element'),
  ));

  const repeat = GrammarRule('repeat', GrammarAlternative(
    GrammarRepeatOneOrMore(
      GrammarRuleIdentifier('DIGIT'),
    ),
    GrammarConcat(
      GrammarRepeatZeroOrMore(
        GrammarRuleIdentifier('DIGIT'),
      ),
      GrammarString('*'),
      GrammarRepeatZeroOrMore(
        GrammarRuleIdentifier('DIGIT'),
      ),
    ),
  ));

  const element = GrammarRule('element', GrammarAlternative(
    GrammarRuleIdentifier('rulename'),
    GrammarRuleIdentifier('group'),
    GrammarRuleIdentifier('option'),
    GrammarRuleIdentifier('char-val'),
    GrammarRuleIdentifier('num-val'),
    GrammarRuleIdentifier('prose-val'),
  ));

  const group = GrammarRule('group', GrammarConcat(
    GrammarString('('),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
    GrammarRuleIdentifier('alternation'),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
    GrammarString(')'),
  ));

  const option = GrammarRule('option', GrammarConcat(
    GrammarString('['),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
    GrammarRuleIdentifier('alternation'),
    GrammarRepeatZeroOrMore(
      GrammarRuleIdentifier('c-wsp'),
    ),
    GrammarString(']'),
  ));

  const char_val = GrammarRule('char-val', GrammarConcat(
    GrammarRuleIdentifier('DQUOTE'),
    GrammarRepeatZeroOrMore(
      GrammarAlternative(
        GrammarByteRange(0x20, 0x21),
        GrammarByteRange(0x23, 0xee7),
      ),
    ),
    GrammarRuleIdentifier('DQUOTE'),
  ));

  const num_val = GrammarRule('num-val', GrammarConcat(
    GrammarString('%'),
    GrammarAlternative(
      GrammarRuleIdentifier('bin-val'),
      GrammarRuleIdentifier('dec-val'),
      GrammarRuleIdentifier('hex-val'),
    ),
  ));

  const bin_val = GrammarRule('bin-val', GrammarConcat(
    GrammarString('b'),
    GrammarRepeatOneOrMore(
      GrammarRuleIdentifier('BIT'),
    ),
    GrammarOptional(
      GrammarAlternative(
        GrammarRepeatOneOrMore(
          GrammarConcat(
            GrammarString('.'),
            GrammarRepeatOneOrMore(
              GrammarRuleIdentifier('BIT'),
            ),
          )
        ),
        GrammarConcat(
          GrammarString('-'),
          GrammarRepeatOneOrMore(
            GrammarRuleIdentifier('BIT'),
          ),
        )
      )
    ),
  ));

  const dec_val = GrammarRule('dec-val', GrammarConcat(
    GrammarString('d'),
    GrammarRepeatOneOrMore(
      GrammarRuleIdentifier('DIGIT'),
    ),
    GrammarOptional(
      GrammarAlternative(
        GrammarRepeatOneOrMore(
          GrammarConcat(
            GrammarString('.'),
            GrammarRepeatOneOrMore(
              GrammarRuleIdentifier('DIGIT'),
            ),
          )
        ),
        GrammarConcat(
          GrammarString('-'),
          GrammarRepeatOneOrMore(
            GrammarRuleIdentifier('DIGIT'),
          ),
        )
      )
    ),
  ));

  const hex_val = GrammarRule('hex-val', GrammarConcat(
    GrammarString('x'),
    GrammarRepeatOneOrMore(
      GrammarRuleIdentifier('HEXDIG'),
    ),
    GrammarOptional(
      GrammarAlternative(
        GrammarRepeatOneOrMore(
          GrammarConcat(
            GrammarString('.'),
            GrammarRepeatOneOrMore(
              GrammarRuleIdentifier('HEXDIG'),
            ),
          )
        ),
        GrammarConcat(
          GrammarString('-'),
          GrammarRepeatOneOrMore(
            GrammarRuleIdentifier('HEXDIG'),
          ),
        )
      )
    ),
  ));

  const prose_val = GrammarRule('prose-val', GrammarConcat(
    GrammarString('<'),
    GrammarAlternative(
      GrammarByteRange(0x20, 0x3d),
      GrammarByteRange(0x3f, 0x7e),
    ),
    GrammarString('>'),
  ));

  const grammar = Grammar([
    ...ABNF_RULES,
    rulelist,
    rule,
    rulename,
    defined_as,
    elements,
    c_wsp,
    c_nl,
    comment,
    alternation,
    concatenation,
    repetition,
    repeat,
    element,
    group,
    option,
    char_val,
    num_val,
    bin_val,
    dec_val,
    hex_val,
    prose_val,
  ]);

  // TODO support buffer access out-of-range (MUST return an error)

  const compiledGrammar = compileGrammarToJavascriptParseUint8ArrayToAstFunction(grammar);
  const rules = compiledGrammar();

  const buffer = new TextEncoder().encode(`
     postal-address   = name-part
  `.trim().replace(/\n/g, '\r\n'));
  console.log(buffer);

  const tree = rules.get('rulelist')!(buffer, 0);

  console.log(tree);

  printGrammarError(buffer, tree as any);
}

/*---------*/

export async function codecDebug(): Promise<void> {
  // grammarDebug1();
  // grammarDebug2();
  // grammarDebug3();
  grammarDebugABNF();
}
