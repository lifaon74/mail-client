import { IGrammarConcatAstNode } from '../grammar-concat/grammar-concat-ast-node.type';
import { optimizeGrammarExpression } from './optimize-grammar-expression';
import { IGrammarExpressionAstNode } from '../grammar-expression/grammar-expression-ast-node.type';
import { GrammarEmpty } from '../grammar-byte-sequence-comparison/shortcuts/grammar-empty';
import { GrammarConcat } from '../grammar-concat/grammar-concat';
import { isGrammarByteSequenceComparisonAstNode } from '../grammar-byte-sequence-comparison/grammar-byte-sequence-comparison-ast-node.type';
import {
  IGrammarByteComparisonExpressionAstNode
} from '../grammar-byte-sequence-comparison/comparisons/grammar-byte-comparison-expression-ast-node.type';
import { GrammarByteSequenceComparison } from '../grammar-byte-sequence-comparison/grammar-byte-sequence-comparison';

export function optimizeGrammarConcat(
  node: IGrammarConcatAstNode,
): IGrammarExpressionAstNode {
  const optimizedExpressions: IGrammarExpressionAstNode[] = [];
  let continuousByteSequenceComparison: IGrammarByteComparisonExpressionAstNode[] | undefined = void 0;

  // TODO optimize repetitions

  const appendByteSequenceComparison = (): void => {
    if (continuousByteSequenceComparison !== void 0) {
      optimizedExpressions.push(
        GrammarByteSequenceComparison(
          continuousByteSequenceComparison,
        ),
      );
      continuousByteSequenceComparison = void 0;
    }
  };

  for (let i: number = 0, l: number = node.expressions.length; i < l; i++) {
    const optimizedExpression: IGrammarExpressionAstNode = optimizeGrammarExpression(node.expressions[i]);

    if (isGrammarByteSequenceComparisonAstNode(optimizedExpression)) {
      if (continuousByteSequenceComparison === void 0) {
        continuousByteSequenceComparison = [...optimizedExpression.expressions];
      } else {
        continuousByteSequenceComparison!.push(...optimizedExpression.expressions);
      }
    } else {
      appendByteSequenceComparison();
      optimizedExpressions.push(optimizedExpression);
    }
  }

  appendByteSequenceComparison();

  if (optimizedExpressions.length === 0) {
    return GrammarEmpty;
  } else if (optimizedExpressions.length === 1) {
    return optimizedExpressions[0];
  } else {
    return (
      (optimizedExpressions.length === node.expressions.length)
      && optimizedExpressions.every((optimizedExpression: IGrammarExpressionAstNode, index: number): boolean => {
        return optimizedExpression === node.expressions[index];
      })
    )
      ? node
      : GrammarConcat(optimizedExpressions);
  }
}
