import { u8 } from '@lifaon/number-types';

/*---------*/

interface IEncoderEncoding {
  (): boolean;
}

interface IEncoderGet {
  (): u8;
}

interface IEncoderNext {
  (): void;
}

interface IEncoderRead {
  (): u8;
}

interface IEncoder {
  encoding: IEncoderEncoding; // rename 'live' or 'active', 'incomplete', 'inProgress'
  get: IEncoderGet;
  next: IEncoderNext;
  read: IEncoderRead;
}

interface ICreateEncoder<GInput> {
  (
    input: GInput,
  ): IEncoder;
}

function createEncoderFromGenerator(
  generator: () => Iterator<u8>,
): IEncoder {
  return createEncoderFromIterator(generator());
}

function createEncoderFromIterator(
  iterator: Iterator<u8>,
): IEncoder {
  let _result: IteratorResult<u8>;

  const encoding = (): boolean => {
    if (_result === void 0) {
      _result = iterator.next();
    }
    return !_result.done;
  };

  const get = (): u8 => {
    if (_result.done) {
      throw new Error(`Done`);
    } else {
      return _result.value;
    }
  };

  const next = (): void => {
    _result = iterator.next();
  };

  const read = (): u8 => {
    let value: u8 = get();
    next();
    return value;
  };

  return {
    encoding,
    get,
    next,
    read,
  };
}

/*---------*/

interface IIDecoderDecoding {
  (): boolean;
}

interface IDecoder<GOutput> {
  decoding: IIDecoderDecoding;
}

interface ICreateDecoder<GOutput> {
  (): IDecoder<GOutput>;
}

function createDecoderFromIterator<GOutput>(
  iterator: Iterator<u8>,
): IDecoder<GOutput> {
  // TODO continue here
  let _result: IteratorResult<u8>;

  const encoding = (): boolean => {
    if (_result === void 0) {
      _result = iterator.next();
    }
    return !_result.done;
  };

  const get = (): u8 => {
    if (_result.done) {
      throw new Error(`Done`);
    } else {
      return _result.value;
    }
  };

  const next = (): void => {
    _result = iterator.next();
  };

  const read = (): u8 => {
    let value: u8 = get();
    next();
    return value;
  };

  return {
    encoding,
    get,
    next,
    read,
  };
}

/*---------*/

function createTextEncoder(
  input: string,
): IEncoder {
  return createEncoderFromGenerator(function* () {
    yield* new TextEncoder().encode(input);
  });
}

function createTextDecoder(): IDecoder<string> {
  return createDecoderFromIterator(function* () {
    yield* new TextEncoder().encode(input);
  });
}

/*---------*/

/*

CODEC:
X Data IN
Y Data OUT
backpressure

encoder.read();

 */


/*---------*/

export async function codecDebug(): Promise<void> {
  const encoder = createTextEncoder('abc');

  while (encoder.encoding()) {
    console.log(encoder.read());
  }

  // while (!decoder.done()) {
  //   encoder.write(8);
  // }
  // console.log(decoder.get());

}
